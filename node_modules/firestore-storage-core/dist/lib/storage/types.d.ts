declare const t: unique symbol;
export type Id<T> = string & {
    readonly [t]: T;
};
export interface BaseModel {
    id: string;
    _rawPath: string;
}
export type ModelDataOnly<T> = Omit<T, keyof BaseModel>;
export type ModelDataWithId<T extends BaseModel> = Pick<T, 'id'> & ModelDataOnly<T>;
export type ModelQuery<T extends BaseModel> = Partial<ModelDataOnly<T>>;
export interface ReferenceMap {
    [id: string]: boolean;
}
export declare function toReferenceMap(...entities: BaseModel[]): ReferenceMap;
export declare function toReferenceMapFromIds(ids: string[], value?: any): ReferenceMap;
export declare function isSameReferenceMap(r1: ReferenceMap, r2: ReferenceMap): boolean;
type NestedPartial<T> = {
    [K in keyof T]?: T[K] extends Array<infer R> ? Array<R> : NestedPartial<T[K]>;
};
export type PatchUpdate<T extends {
    id: string;
}> = Required<Pick<T, 'id'>> & Omit<NestedPartial<T>, 'id'>;
export {};
//# sourceMappingURL=types.d.ts.map